\documentclass[12pt]{article}

\usepackage[margin=1.2in]{geometry}
\usepackage{setspace}
\usepackage[backend=bibtex,style=verbose-trad2]{biblatex}
\usepackage{rotating}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{mathtext}
\usepackage{commath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{algorithm2e}
\usepackage{mathtools}
\usepackage{stackrel}
\usepackage{indentfirst}
\usepackage{geometry}
%\usepackage{tikz}
%\usepackage{tkz-euclide}
%\usepackage{diagbox}
%\usetkzobj{all}
%\usetikzlibrary{arrows,positioning}
%\usetikzlibrary{shapes,snakes}
%\usetikzlibrary{shapes.multipart}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{float}
\usepackage{bbm}
\usepackage{listings}
\usepackage[section]{placeins}

% for inline R code: if the inline code is not correctly parsed, you will see a message
\newcommand{\rinline}[1]{SOMETHING WRONG WITH knitr}
\newcommand{\dquad}{\,\dif x_1\,\dif x_2\, \dif x_3\, \dif x_4\,}
%% begin.rcode setup, include=FALSE
% library(knitr)
% library(lattice)
% library(latticeExtra)
% library(reshape)
% library(png)
% library(ggplot2)
% library(scales)

%fst.frel <-read.csv('./data/p35p_data.csv')
%snd.frel <-read.csv('./data/p4p_data.csv')
%fst.noisy <-read.csv('./data/p35p_data_noisy.csv')
%snd.noisy <-read.csv('./data/p4p_data_noisy.csv')
%% end.rcode

\begin{document}
\section{Intoduction}
In this document, there are performance results of P3.5Pf and P4Pf algorithms on data generated according (more or less) to the articles.

\section{Noise-free data}
Firstly, P3.5Pf and P4Pf were tested on data from P3.5Pf article.
The focal length was randomly chosen from 200 to 2000 pixels, 3D points from $[-2,2]\times[-2,2]\times[4,8]$ and also a rotation and a translation.
The relative focal length error was compared, for plots see \ref{p35p}. 
Results, comparing to the article plots, seem worse since the proposed solution peaked at $1e-14$ and ours peaks at $1e-13$


%%begin.rcode removing_nan, echo=F
%fst.frel <- fst.frel[complete.cases(fst.frel), ]
%snd.frel <- snd.frel[complete.cases(snd.frel), ]
%%end.rcode

%% begin.rcode dividing_frel, echo=F
%fst.frel.double<-subset(fst.frel, algorithm == 'p35pf_double' | algorithm == 'p4pf_double', select = c("algorithm", "df"))
%fst.frel.single<-subset(fst.frel, algorithm == 'p35pf_single' | algorithm == 'p4pf_single', select = c("algorithm", "df"))
%snd.frel.double<-subset(snd.frel, algorithm == 'p35pf_double' | algorithm == 'p4pf_double', select = c("algorithm", "df"))
%snd.frel.single<-subset(snd.frel, algorithm == 'p35pf_single' | algorithm == 'p4pf_single', select = c("algorithm", "df"))
%% end.rcode

\begin{figure}[h!]
\begin{subfigure}{1.0\textwidth}
%%begin.rcode message=F, warning=F, echo=F, fig.height=2.4, fig.width=6
%ggplot(fst.frel.double, aes(df, colour = algorithm)) + geom_density() + scale_x_log10(labels = trans_format("log10", math_format(.x))) + xlab("focus")
%%end.rcode
\end{subfigure}
\vskip\baselineskip
\begin{subfigure}{1.0\textwidth}
%%begin.rcode message=F, warning=F, echo=F, fig.height=2.4, fig.width=6
%ggplot(fst.frel.single, aes(df, colour = algorithm)) + geom_density() + scale_x_log10(labels = trans_format("log10", math_format(.x))) + xlab("focus")
%%end.rcode
\end{subfigure}
\label{p35p}
\caption{Results on P3.5Pf article data}
\end{figure}

In P4Pf article there was similar data generation technique, but 3D points were chosen from $ [-10, 10] ^3$ cube, and focal length from $ [0.5, 5] $.
Since I am not sure how to normalize image coordinates beforehand, especially with noise addition, the decision has been made to choose the focal length from the same interval as in P4Pf article but use normalization after.
So the focal length and image coordinates were divided by the diagonal of the generated image. This plot does not look worse but that may be due to the wrong data generation choise.

\begin{figure}[h!]
\begin{subfigure}{1.0\textwidth}
%%begin.rcode message=F, warning=F, echo=F, fig.height=2.4, fig.width=6
%ggplot(snd.frel.double, aes(df, colour = algorithm)) + geom_density() + scale_x_log10(labels = trans_format("log10", math_format(.x))) + xlab("focus")
%%end.rcode
\end{subfigure}
\hfill
\begin{subfigure}{1.0\textwidth}
%%begin.rcode message=F, warning=F, echo=F, fig.height=2.4, fig.width=6
%ggplot(snd.frel.single, aes(df, colour = algorithm)) + geom_density() + scale_x_log10(labels = trans_format("log10", math_format(.x))) + xlab("focus")
%%end.rcode
\end{subfigure}
\caption{Results on P4Pf article data}
\end{figure}

%% begin.rcode dividing_noisy_fst, echo=F
%fst.noisy.double <-subset(fst.noisy, algorithm == 'p35pf_double' | algorithm == 'p4pf_double', select = c("algorithm", "stdev", "df"))
%fst.noisy.double  <- fst.noisy.double [complete.cases(fst.noisy.double ), ]
%fst.noisy.double <-aggregate(fst.noisy.double[,c("df")], 
%               by = list(algorithm = fst.noisy.double$algorithm, noise = fst.noisy.double$stdev), 
%               FUN = median)

%fst.noisy.single <-subset(fst.noisy, algorithm == 'p35pf_single' | algorithm == 'p4pf_single', select = c("algorithm", "stdev", "df"))
%fst.noisy.single  <- fst.noisy.single [complete.cases(fst.noisy.single ), ]
%fst.noisy.single <-aggregate(fst.noisy.single[,c("df")], 
%               by = list(algorithm = fst.noisy.single$algorithm, noise = fst.noisy.single$stdev), 
%               FUN = median)

%%end.rcode

\section{Noisy data}

In both of the articles for tests with noisy data focal distance was fixed, in P3.5Pf $f = 200$ and in P4Pf $f = 1.7$.
Since in the latter article type of noise was not specified, I assumed it was the same as in the P3.5Pf article -- zero-mean Gaussian noise.
Below you can find the plot results.

\begin{figure}[h!]
\begin{subfigure}{1.0\textwidth}
%%begin.rcode message=F, warning=F, echo=F, fig.height=2.4, fig.width=6
%ggplot(fst.noisy.double, aes(x = noise, y = x, colour = algorithm)) + geom_line() + xlab("stedv")
%%end.rcode
\end{subfigure}
\vskip\baselineskip
\begin{subfigure}{1.0\textwidth}
%%begin.rcode message=F, warning=F, echo=F, fig.height=2.4, fig.width=6
%ggplot(fst.noisy.single, aes(x = noise, y = x, colour = algorithm)) + geom_line() + xlab("stedv")
%%end.rcode
\end{subfigure}
\caption{In P3.5P article there was presented a plot for median of the relative focal error for different standard devations}
\end{figure}



%% begin.rcode dividing_noisy_snd, echo=F
%snd.noisy.double <-subset(snd.noisy, algorithm == 'p35pf_double' | algorithm == 'p4pf_double', select = c("algorithm", "stdev", "df"))
%snd.noisy.double  <- snd.noisy.double [complete.cases(snd.noisy.double ), ]
%snd.noisy.double$stdev <- as.character(snd.noisy.double$stdev)

%snd.noisy.single <-subset(snd.noisy, algorithm == 'p35pf_single' | algorithm == 'p4pf_single', select = c("algorithm", "stdev", "df"))
%snd.noisy.single  <- snd.noisy.single [complete.cases(snd.noisy.single ), ]
%snd.noisy.single$stdev <- as.character(snd.noisy.single$stdev)
%%end.rcode

\begin{figure}[h!]
\begin{subfigure}{1.0\textwidth}
%%begin.rcode message=F, warning=F, echo=F, fig.height=2.4, fig.width=6
%ggplot(snd.noisy.double, aes(x = stdev, y = df, colour = algorithm)) + geom_boxplot() + ylim(1.5, 1.9)
%%end.rcode
\end{subfigure}
\vskip\baselineskip
\begin{subfigure}{1.0\textwidth}
%%begin.rcode message=F, warning=F, echo=F, fig.height=2.4, fig.width=6
%ggplot(snd.noisy.single, aes(x = stdev, y = df, colour = algorithm))  + geom_boxplot() + ylim(1.5, 1.9)
%%end.rcode
\end{subfigure}
\caption{In P4P article there was a boxplot of focal length for different errors in pixels}
\end{figure}




\end{document}